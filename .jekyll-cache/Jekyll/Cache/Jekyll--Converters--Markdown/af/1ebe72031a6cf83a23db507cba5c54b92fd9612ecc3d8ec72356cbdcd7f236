I"#<blockquote>
  <p>ES6学习笔记</p>
</blockquote>

<h3 id="let">let</h3>
<p>let不能被重复声明
不存在变量提升
let声明的变量只在当前（块级）作用域内有效</p>

<h3 id="const">const</h3>

<p>不存在提升
一旦声明变量 就不能再改变（引用类型需要冻结）</p>

<h3 id="数组">数组</h3>

<p>const arr=[‘a’,’b’,’c’,’d’,[‘d’,’e’,[‘f’,’g’]]];
const [,,,,[,,[,g]]]=arr
为g取值，数组前有几位，就多几个，</p>

<h4 id="扩展运算符">扩展运算符</h4>

<p>const arr[1,2,3,4,5]
const [a,b,….c]=arr
1和2赋值给了ab,剩下的全归c</p>

<h4 id="默认值">默认值</h4>
<p>const arr=[1,undefined,undefined];
const [a,b=2,c,d=’aaa’]=arr;
这里a为数组里的1，而b设置了默认值为2，d设置了默认值为aaa，c没有默认值，取不到值所以为undefined</p>

<h4 id="变量的交换">变量的交换</h4>
<p>原始的方法为
temp=a;
a=b
b=temp
但现在可以这样
[a,b]=[b,a]</p>

<h4 id="接受多个函数返回值">接受多个函数返回值</h4>

<p>funtion getUserInfo(id){</p>

<p>//..ajax</p>

<p>return[</p>

<p>true,</p>

<p>{</p>

<p>name:’小明’,</p>

<p>gender:’女’,</p>

<p>id:id},</p>

<p>‘请求成功’</p>

<p>];};</p>

<p>原始方式:const resData=getUserInfo(123);</p>

<p>let status=resData[0]一个一个的取</p>

<p>现在const[status,data,msg]=getUserInfo(123)</p>

<h3 id="对象">对象</h3>

<p>解构赋值</p>

<p>const{a,b}={a:1,b;2}</p>

<p>左边｛｝为需要赋值的变量，右边为需要解构的对象</p>

<h4 id="对象稍微复杂的解构条件">对象：稍微复杂的解构条件</h4>

<p>const player={</p>

<p>nickname:’感情的戏我没演技’，</p>

<p>master:’东海龙王’,</p>

<p>skill：[{</p>

<p>skillName:’龙吟’,</p>

<p>mp:’100’,</p>

<p>time:6000</p>

<p>},{</p>

<p>skillName:’龙卷雨击’,</p>

<p>mp:‘’400’</p>

<p>time:3000</p>

<p>}，｛</p>

<p>skillName:’龙腾’,</p>

<p>mp:‘900’，</p>

<p>time:60000</p>

<p>}]</p>

<p>};</p>

<p>const｛nickname｝=player ：取感情的戏我没演技</p>

<p>const{master} =player:取东海龙王</p>

<p>const{skill:[skill1]}=player :取第一个数组</p>

<p>const{skill:[skill1,{skillName}]}=player ：取第二个数组的龙卷雨</p>

<p>const{skill:[skill1,{skillName}，｛skliName: sklName｝]}=player 取第三个龙腾，并为了防止名字重复重新起一个新名字</p>

<h4 id="结合扩展运算符">结合扩展运算符</h4>

<p>const obj={</p>

<p>saber:’阿尔托利亚’，</p>

<p>archer：’卫宫’，</p>

<p>lancer:’瑟坦达’</p>

<p>}；</p>

<p>const{saber,…oth}=obj</p>

<h5 id="把obj1的所有属性放到obj里">把obj1的所有属性放到obj里</h5>

<p>const obj1={</p>

<p>archer:’卫宫’,</p>

<p>lancer：‘瑟坦达’</p>

<p>}</p>

<p>const obj={</p>

<p>saber:‘阿尔托利亚,</p>

<p>…obj1</p>

<p>}</p>

<h4 id="对已经申明了的变量进行对象的解构赋值">对已经申明了的变量进行对象的解构赋值</h4>

<p>let age;</p>

<p>const obj={</p>

<p>name:’小明’,</p>

<p>age:22</p>

<p>}；</p>

<p>{age}=obj ;此时将age误认为了块级作用域，无法赋值得加上（）</p>

<p>({age}=obj)即可</p>

<h3 id="默认值-1">默认值</h3>

<p>let girlfriend={</p>

<p>name:’小红’,</p>

<p>age:undefined,</p>

<p>};</p>

<p>let {name,age=24,hobby=[‘学习’]}=girlfriend;</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var {foo:baz} = {foo:"aaa",bar:"bbb"};
    baz //aaa
</code></pre></div></div>

<p>对于以上代码而言，被赋值的是baz而不是foo</p>

<h4 id="-获取多个函数返回值">#### 获取多个函数返回值</h4>

<p>function getUserInfo(uid){</p>

<p>//ajax</p>

<p>return{</p>

<p>status:true,</p>

<p>data:{</p>

<p>name:’小红’,</p>

<p>},</p>

<p>msg:’请求成功’</p>

<p>};</p>

<p>};</p>

<p>const{status,data,msg}=getUserInfo(123);</p>

<p>练习</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let node = {
    type:"id",
    name: "ES",
    loc:{
        start:["line","column"],
        end:{
        line:1,
        column:4
    }
}
}
const{type,name,loc:{start:[line,ccc,foo=2],end:{line:key}}}=node
</code></pre></div></div>

<h4 id="字符串的解构赋值">字符串的解构赋值</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const str = 'I am the bone of my sword'; // 我是剑骨头

//const [ a, b ,c, ...oth ] = str;//根据前后顺序获取字符

//const [ ...spStr1 ] = str;//获取全部字符
//const spStr2 = str.split(' ');//以空格分割字，获取由空格隔开的所以字符组
//const spStr3 = [ ...str ];

// ------------------------------------------

// 提取属性

//const { length, split } = str;
</code></pre></div></div>

<h4 id="函数参数解构赋值">函数参数解构赋值</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 函数参数的解构赋值
function swap([x, y]) {
	return [y, x];
};
let arr = [1, 2];
arr = swap(arr);
// -----------------
function Computer({
	cpu,
	memory
	software = ['ie6'],
	OS = 'windows 3.5'
}) {
	console.log(cpu);
	console.log(memory);
	console.log(software);
	console.log(OS);

};
new Computer({
	memory: '128G',
	cpu: '80286',
	OS: 'windows 10'
});
</code></pre></div></div>

<p>#### 字符串中添加值</p>

<p>const name =’woniu’</p>

<p>console.log(‘</p>

<p>hello ${name}!!!</p>

<p>hello world</p>

<p>’)</p>

<h4 id="箭头函数">箭头函数</h4>

<p>const double=(num)=&gt;num*2</p>

<p>const add (num1,num2)=&gt;{</p>

<p>return num1+num2</p>

<p>}</p>

<p>console.log(add(3,4))</p>

<p>const add1=(num1,num2=1)=&gt;{return num1+num2}给num2设定默认值</p>

<p>console.log(add(3))</p>

<h4 id="展开符">展开符</h4>

<p>let arr=[5,6]</p>

<p>console.log(add(…arrr)) //输出11</p>

<p>console.log ([123,….arrr])对数组进行合并</p>

<h4 id="对象扩展">对象扩展</h4>

<p>对象的一个简写形式</p>

<p>const key =’job’</p>

<p>const obj={</p>

<p>num=1,</p>

<p>str:’woniu’,</p>

<p>work(){},  //原先的形式为work:function(){}</p>

<p>}</p>

<p>console.log(obj)</p>

<h4 id="解构赋值">解构赋值</h4>

<p>交换赋值</p>

<p>let arr =[1,2]</p>

<p>let[num1,num2]=arr</p>

<p>const obj=｛type:’IT’,name’world’｝</p>

<p>const{type,name}=obj</p>

<h4 id="模块化">模块化</h4>

<p>新建JS文件 module1</p>

<p>export const name =’woniu123’</p>

<p>export function sayHello(){console.log(‘hello world’)}</p>

<p>export default funciton(){console.log(‘vuejs 还不错’)} //使用默认值</p>

<p>主文件引用</p>

<p>import {name}from ‘./module1’ //输出woniu123</p>

<p>import sayHi from ‘,/module1’ //使用默认值可以随意命名且不用加大括号</p>

<h3 id="es6常用代码片段">ES6常用代码片段</h3>

<p>let arr=[1,2,3,4]</p>

<h5 id="遍历">遍历</h5>

<p>arrr.forEach(v=&gt;){</p>

<p>console.log(v)    //全部打印一遍</p>

<p>}</p>

<p>console.log(arr.map(v=&gt;v*2) ) //打印出将数组内所有数的二倍值</p>

<p>console.log(arr.every(v=&gt;v&gt;0) )判断数组内的所有值是否都大于0   返回true说明全部大于0</p>

<p>console.log(arr.every(v=&gt;v&gt;2) )判断数组内所有值是否都大于2，返回false</p>

<p>console.log(arr.filter(v=&gt;v&gt;3)）输出保留数组内大于3的数据</p>

<p>console.log(arr.filter(v=&gt;v&lt;=3).map(v=&gt;v*3)） //可以链式调用，在一个方法后再加一个方法</p>

<h5 id="数组去重">数组去重</h5>

<p>let arr1=[1,2,3,4,2,3]</p>

<p>let arr2=[4,3,6,8]</p>

<p>console.log(new Set(arr1))//去除arr1数组内重复的值 输出Set{1,2,3,4}</p>

<p>console.log([…new Set(arr1)]) //去除arr1数组内重复的值且输出为数组 输出[1,2,3,4]</p>

<p>//并集</p>

<p>console.log([…new Set([…arr1,…arr2])]) //2个数组去重后合并的结果</p>

<p>//页面使用了多少种标签</p>

<p>document.querySelectorAll(‘*‘)查询到所有标签</p>

<p>[…document.querySelectorAll(‘*’)].map(v=&gt;v.nodeName) //将其变为数组</p>

<p>Set([…document.querySelectorAll(‘*’)].map(v=&gt;v.nodeName))//将其变为数组</p>

<p>new Set([…document.querySelectorAll(‘*’)].map(v=&gt;v.nodeName)).size获取使用的标签</p>

<p>//对象扩展</p>

<p>//遍历</p>

<p>const obj1={</p>

<p>name:woniu,</p>

<p>age:18</p>

<p>}</p>

<p>const obj2={</p>

<p>funllName:’woniu1’,</p>

<p>sex:’male’</p>

<p>}</p>

<p>Object.keys(obj1).forEach(v=&gt;{console.log(v,obj1[v])//遍历对象</p>

<p>})</p>

<p>console.log({…obj1,job:fe,age:16}) //进行了取值，合并，修改的操作输出name:’woniu’,age:’16’,job:’fe’</p>

<p>console.log({…obj1,…obj2,job:’fe’,age:16}) 对象的合并操作</p>

:ET